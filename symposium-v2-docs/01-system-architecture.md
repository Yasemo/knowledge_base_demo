# System Architecture

## High-Level Overview

Symposium v2 is built on a **pipeline architecture** where data flows through
distinct stages:

```
┌─────────────────────────────────────────────────────────────────┐
│                         SYMPOSIUM V2                             │
│                   Data Orchestration Platform                    │
└─────────────────────────────────────────────────────────────────┘

┌──────────────┐      ┌───────────┐      ┌──────────────┐
│ Integration  │  →   │  Sources  │  →   │Content Cards │
│   Types      │      │ (Configs) │      │  (Storage)   │
└──────────────┘      └───────────┘      └──────────────┘
       ↓                    ↓                    ↓
┌──────────────┐      ┌───────────┐      ┌──────────────┐
│Integrations  │  →   │  Queries  │  →   │Content Cards │
│(Credentials) │      │(Aggregate)│      │  (Digests)   │
└──────────────┘      └───────────┘      └──────────────┘
                            ↓                    ↓
                      ┌───────────┐      ┌──────────────┐
                      │  Outputs  │  ←   │   Views      │
                      │ (Deliver) │      │  (Filters)   │
                      └───────────┘      └──────────────┘
                            ↓
                      ┌───────────┐
                      │ External  │
                      │ Systems   │
                      └───────────┘

                  ┌─────────────────┐
                  │ GLOBAL SCHEDULER│
                  │  (Orchestrates) │
                  └─────────────────┘
```

## Core Components

### 1. Integration Layer

**Purpose**: Connect to external services

```
Integration Type (Blueprint)
  ├── Authentication Schema (how to connect)
  ├── Source Schema (what config sources need)
  ├── Output Schema (what config outputs need)
  └── Capabilities (rate limits, features)

Integration Instance (User Config)
  ├── Type Reference
  ├── Credentials (encrypted)
  ├── Custom Settings
  └── Status (active/inactive)
```

**Key Concepts**:

- Integration Types are **dev-defined** (we add Perplexity, GitHub, Mailchimp)
- Users create **Integration Instances** with their credentials
- One integration type → many user instances

### 2. Source Layer

**Purpose**: Generate content cards from external data

```
Source
  ├── Integration Reference
  ├── Configuration (API params)
  ├── Tags (applied to generated cards)
  └── Schedule (optional cron)
      ↓
  Execution → Content Card (type: source)
```

**Characteristics**:

- Each source = one configured API call
- Can be executed manually or on schedule
- Generates one card per execution
- Cards store the API request for future refresh

### 3. Query Layer

**Purpose**: Aggregate multiple sources into digest cards

```
Query
  ├── Multiple Source References (ordered)
  ├── Aggregation Template (Handlebars)
  ├── Tags (for resulting card)
  └── Schedule (optional cron)
      ↓
  Execution → Execute Each Source → Content Card (type: query)
```

**Characteristics**:

- Queries execute multiple sources in sequence
- Results are combined using a template
- Produces a single digest card
- Useful for daily briefs, weekly roundups

### 4. Output Layer

**Purpose**: Deliver cards to external systems

```
Output
  ├── Integration Reference
  ├── Card Filter (which cards to include)
  ├── Formatting Template
  └── Schedule (optional cron)
      ↓
  Execution → Filter Cards → Format → Send to External System
```

**Characteristics**:

- Selects cards using views/tags/filters
- Formats using template
- Delivers to integration (email, Slack, etc.)
- Does not create cards

### 5. Content Card Storage

**Purpose**: Central repository of all knowledge

```
Content Card
  ├── Type (manual | source | query)
  ├── Schema & Field Data
  ├── Rich Markdown Content
  ├── Tags (for organization)
  ├── Source/Query Reference (if generated)
  └── API Request (for refresh capability)
```

**Card Types**:

- **Manual**: User-created through forms
- **Source**: Auto-generated by source execution
- **Query**: Auto-generated by query execution

### 6. Scheduling System

**Purpose**: Unified time-based execution management

```
Global Scheduler
  ├── Monitors: Sources, Queries, Outputs
  ├── Evaluates: Cron expressions
  ├── Executes: On schedule match
  └── Tracks: Execution history
```

**Schedule Flow**:

```
Every 30 seconds:
  1. Check all sources with schedule_enabled=true
  2. Check all queries with schedule_enabled=true  
  3. Check all outputs with schedule_enabled=true
  4. Execute any where next_run_at <= now
  5. Calculate and update next_run_at
  6. Log execution results
```

### 7. View & Filter System

**Purpose**: Organize and select cards

```
View
  ├── Filter Expression (schemas, tags, fields)
  ├── Sort Configuration
  └── Display Mode (grid, list, table, carousel)
      ↓
  Evaluates Against All Cards → Filtered Subset
```

**Usage**:

- Organize cards for user interface
- Select cards for outputs
- Base for showcases

### 8. Showcase System

**Purpose**: Public presentation of card collections

```
Showcase
  ├── View Reference (source of cards)
  ├── Layout Configuration (tabs, theme)
  ├── Rendered HTML (cached)
  └── Public URL
```

**Generation Flow**:

```
1. Get cards from view filter
2. Render each card's markdown → HTML
3. Apply layout (tabbed sidebar)
4. Generate static HTML file
5. Store hash of card IDs + timestamps
6. Serve cached version until cards change
7. Regenerate when cards_hash doesn't match
```

### 9. Policy System

**Purpose**: External access control

```
Connection Policy
  ├── Type (input | output)
  ├── Connection String (auth token)
  ├── View References (for output)
  ├── Schema Reference (for input)
  └── Expiration (optional)
```

**Policy Types**:

- **Output**: External systems fetch filtered cards
- **Input**: External systems create cards

## Data Flow Patterns

### Pattern 1: Manual Card Creation

```
User → Schema Selection → Dynamic Form → Card Data
  → Validation → Database → Content Card
```

### Pattern 2: Scheduled Source Execution

```
Scheduler → Source Due → Integration Handler → API Call
  → Response → Card Data → Database → Content Card (source)
    → Update next_run_at
```

### Pattern 3: Query Aggregation

```
Scheduler → Query Due → For Each Source:
  → Execute Source → Store Result
    → Apply Aggregation Template → Card Data
      → Database → Content Card (query)
        → Update next_run_at
```

### Pattern 4: Output Delivery

```
Scheduler → Output Due → Apply Filter → Get Cards
  → Apply Template → Format Data
    → Integration Handler → External API → Delivery
      → Update next_run_at
```

### Pattern 5: Showcase Viewing

```
User Request → Public URL → Check cards_hash
  → If Changed: Regenerate HTML
    → If Same: Serve Cached HTML
      → Response
```

## System States

### Execution States

- **Running**: Currently executing
- **Success**: Completed successfully
- **Failure**: Encountered error
- **Partial**: Some operations succeeded

### Schedule States

- **Active**: Enabled and running
- **Paused**: Disabled temporarily
- **Expired**: Past expiration date

### Card States

- **Fresh**: Content up to date
- **Stale**: Source config changed, needs refresh

## Scalability Considerations

### Database

- **Indexing**: Critical for tag filtering, date ranges, card types
- **JSONB GIN indexes**: Essential for field filtering
- **Partitioning**: Consider for large card volumes (by created_at)

### Scheduler

- **Distributed**: Can run multiple scheduler instances
- **Locking**: Use PostgreSQL advisory locks for execution claims
- **Priority**: High-frequency schedules processed first

### Integration Rate Limits

- **Tracking**: Monitor requests per integration instance
- **Queuing**: Queue executions when rate limits approached
- **Backoff**: Exponential backoff on failures

### Storage

- **Content**: Markdown stored as TEXT (compress if needed)
- **Rendered HTML**: Cache in showcases table
- **Attachments**: Consider external object storage

## Security Architecture

### Credential Storage

- Encrypt integration credentials at rest
- Use environment variables for encryption keys
- Never expose credentials in API responses

### Connection Strings

- Generate cryptographically random tokens
- Include expiration dates
- Rate limit external API access

### Access Control

- User-based isolation (all queries filter by user_id)
- Policy-based external access
- No authentication for public showcases (intentional)

## Error Handling Strategy

### Integration Failures

```
API Call Fails
  → Log error details
    → Mark execution as 'failure'
      → Increment failure count
        → If failures > threshold: Disable integration
          → Notify user
```

### Partial Failures

```
Query with 3 Sources: 2 succeed, 1 fails
  → Create card with available data
    → Mark execution as 'partial'
      → Include error details in result_summary
```

### Cascade Handling

```
Source A fails in Query B
  → Query B continues with remaining sources
    → Notes missing source in generated card
      → User can manually retry failed source
```

## Extension Points

### Adding New Integration Types

1. Define integration type schema (auth, source, output)
2. Implement handler (execute, send methods)
3. Register in integration_types table
4. Users can now create instances

### Custom Field Types

1. Add field type to schema system
2. Implement form renderer
3. Implement filter evaluator
4. Update validation rules

### New Content Renderers

1. Create renderer plugin
2. Register with content renderer
3. Define code block language
4. Implement render method

## Performance Optimization

### Query Optimization

```sql
-- Use dedicated columns for frequent queries
WHERE card_type = 'source' AND created_at > '2024-01-01'

-- Use JSONB operators for flexible queries  
WHERE data @> '{"priority": "high"}'

-- Use GIN indexes for tag arrays
WHERE tags && ARRAY['ai', 'research']
```

### Caching Strategy

- **Showcase HTML**: Cache until cards change
- **View Results**: Short-lived cache (30s)
- **Integration Schemas**: Cache in memory

### Batch Operations

- Execute multiple sources in parallel (within rate limits)
- Bulk insert cards from queries
- Batch webhook notifications

## Monitoring & Observability

### Key Metrics

- Execution success/failure rates
- Average execution duration
- Cards created per day
- Integration usage patterns
- Scheduler lag (time between due and execution)

### Logging Strategy

- Execution logs: All start/complete/fail events
- API logs: Integration request/response
- Error logs: Detailed error traces
- Audit logs: User actions on sensitive operations

---

**Next**: [Entity Relationships](02-entity-relationships.md)
